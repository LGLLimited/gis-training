---
title: "R for Spatial Analysis"
author: "Julio Novoa"
format: html
editor: visual
---

# Introduction to R for spatial analysis

![Generated by AI](https://dl.imgdrop.io/file/aed8b140-8472-4813-922b-7ce35ef93c9e/2024/10/03/R-Spatial-AI756b793f32f2cbf4.png){fig-align="center"}

## Spatial data types

The 2 basic spatial data types you will encounter are vector and raster data. Vectors are represented by point, lines, polygons, and raster data is represented by a matrix of elements.

![Spatial data types](https://dl.imgdrop.io/file/aed8b140-8472-4813-922b-7ce35ef93c9e/2024/10/03/Vector-Raster607146f0b344278d.png){fig-align="center"}

## Coordinate reference systems

| Geodetic                       | Projected                     |
|--------------------------------|-------------------------------|
| Longitude/Latitude coordinates | XY coordinates (meters, feet) |
| NAD83, WGS84, ...              | UTM, BC Albers, ...           |

![UTM projection](https://dl.imgdrop.io/file/aed8b140-8472-4813-922b-7ce35ef93c9e/2024/10/03/UTM80cd8be066febf32.jpeg){fig-align="center"}

The following example shows Vancouver Island using 2 different CRS at the same screen scale. The distortions in size and shape are evident.

![NAD83 vs BC Albers](https://dl.imgdrop.io/file/aed8b140-8472-4813-922b-7ce35ef93c9e/2024/10/03/NAD83-BCALBERS13155e8807163c4b.png){fig-align="center"}

Here is a web app that can help you find in which UTM zone is located your study area:

[World UTM Grid](https://arcg.is/115zX50)

## Storage data formats

There are several storage formats for geospatial data, from legacy ones such as `Shapefile` or `GeoTIFF` to cloud-optimized ones such as [`GeoParquet`](https://geoparquet.org/), [FlatGeobuf](https://flatgeobuf.org/), [`COG`](https://cogeo.org/), or [`Zarr`](https://zarr.dev/).

In this tutorial we will use a [GeoPackage](https://www.geopackage.org/) file, which is a modern geospatial format that stores vector and raster data layers, as well as symbology and projects from [QGIS](https://www.qgis.org "QGIS"). It is strongly recommended to switch from `Shapefile` to a better format such as `GeoPackage` due to several limitations of Shapefiles.

::: {#gpkg layout-ncol="2"}
![](https://www.geopackage.org/img/geopkg.png){fig-align="center"}

![](https://dl.imgdrop.io/file/aed8b140-8472-4813-922b-7ce35ef93c9e/2024/10/03/GPKGfaab0bf19b6b873b.png){fig-align="center"}
:::

## R Demo

### Data management

In this section we will use the [`sf`](https://r-spatial.github.io/sf/) and [`mapview`](https://r-spatial.github.io/mapview/) packages for data management and visualization. The `sf` package is used to access and perform spatial operations on geospatial data sets, while `mapview` allows us to do quick interactive visualizations.

::: {#packages layout-ncol="2"}
![](https://user-images.githubusercontent.com/520851/34887433-ce1d130e-f7c6-11e7-83fc-d60ad4fae6bd.gif){fig-align="center"}

![](https://github.com/tim-salabim/mvl/blob/master/cartodb_positron/box_mapview.png?raw=true){fig-align="center" width="174"}
:::

Let's set the working directory where all the data sets we need are stored, and define some variables names. This folder also contains a `CSV` file with points longitude/latitude coordinates.

Let's load the R packages:

```{r}
#| output: false
library(tidyverse)
library(sf)
library(mapview)
```

```{r}
# =============================
# set working folder
# setwd("~/YOUR/PATH")
# =============================

# gis data sets
gpkg_file = "gis_datasets.gpkg"
csv_file = "aerodromes.csv"
```

The next step is exploring the layers contained in the GeoPackage file. Here we will verify - for each layer - its name, its geometry, number of features (i.e. rows), number of fields (i.e. columns), and its `CRS` (coordinate reference system).

More information about CRS: [Spatial Reference](https://spatialreference.org/)

```{r}
st_layers(gpkg_file)
```

We will use the function `st_read()` to import each GeoPackage layer into an R variable. Each variable is a data frame, and they contain a new *sticky* column that stores the geometry of each feature.

```{r}
#| output: false
# read GeoPackage layers
island = st_read(dsn = gpkg_file, layer = "vancouver_island")
places = st_read(dsn = gpkg_file, layer = "places")
watercourses = st_read(dsn = gpkg_file, layer = "watercourses")
samples = st_read(dsn = gpkg_file, layer = "samples")
```

Let's verify the `class` of one of these layers.

```{r}
class(places)
```

They are of types `sf` and `data.frame`, so all `tidyverse` operations made on data frames can be executed on these layers, as well as several spatial operation using the `sf` package.

Let's have a glimpse of the contents of the layer called `places`:

```{r}
glimpse(places)
```

If we check the contents of any `sf` layer, we will see a header with information about the number of features (i.e. number of rows), the geometry type of these features (i.e points, lines, polygons), the dimensions of the data (e.g. XY, XYZ), the bounding box (i.e. minimum/maximum coordinates) and the CRS (i.e. geodetic, projected). After this header we can see the data frame contents, including the geometry column called `geom` in this example.

```{r}
places |>
  select(place_name_en)
```

Now, let's create some maps using different plotting tools:

```{r}
# using base R
plot(island$geom)
plot(places$geom, add = TRUE)
```

Using [`ggplot2`](https://ggplot2.tidyverse.org/reference/ggsf.html "Visualize sf objects"), the following set of geometries and coordinates can be used to display `sf` objects:

-   `geom_sf()`

-   `geom_sf_text()`

-   `geom_sf_label()`

-   `coords_sf()`

```{r}
# using ggplot
ggplot() +
  geom_sf(data = island) +
  geom_sf(data = places) +
  geom_sf_text(data=island, aes(label = "Van Isle")) +
  geom_sf_label(data = filter(places, place_name_en == "Victoria"), aes(label = place_name_en))
```

```{r}
# using mapview
mapview(
  list(island, places)
)
```

```{r}
mapview(
    select(places, place_name_en, population_estimate),
    layer.name = "Populated Places",
    col.regions = "red",
    label = "place_name_en",
    popup = TRUE
  ) +
  mapview(
    island,
    layer.name = "Vancouver Island",
    col.regions = "gray",
    alpha.regions = 0,
    label = NA,
    popup = FALSE
    )
  
```

It is always recommended to ensure that all the `sf` layers have the same CRS. Let's verify again the GeoPackage layers:

```{r}
# print GeoPackage layers
st_layers(gpkg_file)
```

The layer `samples` doesn't have a CRS. For this exercise, we will assume all layers have the same CRS (i.e. BC Albers, EPSG=3005), so let's assign that CRS to `samples` using the `st_crs()` function:

```{r}
# assign CRS
st_crs(samples) = 3005
samples
```

Now, we will read a CSV file that has points coordinates expressed as longitude and latitude. The `sf` points object will be created using the function `st_as_sf()`. Next, we will reproject these points from NAD83 (4269) to BC Albers (3005) using the `st_transform()` function, and finally we will extract the coordinates of these points in the BC Albers projection.

```{r}
# read coordinates from a CSV file
csv = read_csv(csv_file)

# create Lon/Lat (NAD83) points layer
aerodromes = st_as_sf(
  csv,
  coords = c('longitude', 'latitude'),
  crs = st_crs(4269),
  remove = FALSE
  )

# reproject NAD83 points to BC Albers and extract coordinates
aerodromes_3005 = aerodromes %>% 
  st_transform(crs = 3005) %>% 
  mutate(bcalbers_x = st_coordinates(.)[, 1]) %>% 
  mutate(bcalbers_y = st_coordinates(.)[, 2])

# results
aerodromes_3005 |>
  as.data.frame() |>
  select(longitude, latitude, bcalbers_x, bcalbers_y) |>
  head(5)
```

The next code block will show how to access ArcGIS Online data sets using the package `arcgislayers`. We will read neighborhood polygons and business locations from the [Open Data Portal](https://opendata.victoria.ca) of the City of Victoria.

```{r}
#| eval: false
library(arcgislayers)

# read directly from ArcGIS Online

# Victoria neighborhoods
url_nhoods = "https://maps.victoria.ca/server/rest/services/OpenData/OpenData_Land/MapServer/4/query?outFields=*&where=1%3D1"
vic_nhoods = arc_open(url_nhoods) |> arc_select()

# Victoria business locations
url_business = "https://maps.victoria.ca/server/rest/services/OpenData/OpenData_PermitsAndLicences/MapServer/1/query?outFields=*&where=1%3D1"
vic_business = arc_open(url_business) |> arc_select()

mapview(
  list(vic_business, vic_nhoods),
  col.regions = list("green", "orange"),
  label = list(NA, "Neighbourhood"),
  legend = list(FALSE, FALSE),
  popup = list(FALSE, FALSE)
)
```

The `arcgislayers` package does not work well with [Quarto](https://quarto.org), so here we use local copies of the same data sets, imported from a CSV and a GeoJSON file.

```{r}
#| output: false
# Victoria business locations (CSV)
vic_business = st_read("business_licences.csv") |>
  st_as_sf(
    coords = c('X', 'Y'),
    crs = st_crs(26910),
    remove = FALSE
    )

# Victoria neighborgoods (GeoJSON) 
vic_nhoods = st_read("neighbourhood_boundaries.geojson") |>
  st_transform(crs = st_crs(vic_business))
```

Let's plot those layers:

```{r}
mapview(
  list(vic_business, vic_nhoods),
  col.regions = list("green", "orange"),
  label = list(NA, "Neighbourhood"),
  legend = list(FALSE, FALSE),
  popup = list(FALSE, FALSE)
)
```

### Spatial Operations

The are several spatial functions that can be applied to single or binary geometry sets of `sf` objects. Here is a list of the most common, and here is also a [cheat sheet](https://ugoproto.github.io/ugo_r_doc/pdf/sf.pdf) with more visual details.

#### Geometric unary operations on geometry sets

-   st_buffer()

-   st_boundary(), st_convex_hull()

-   st_triangulate(), st_triangulate_constrained()

-   st_voronoi()

-   st_polygonize()

-   st_centroid()

#### Geometric operations on pairs geometry sets

-   st_intersection()

-   st_difference(), st_sym_difference()

-   st_snap()

-   st_combine(), st_union()

#### Geometric binary predicates on pairs of geometry sets

-   st_intersects()

-   st_disjoint()

-   st_touches()

-   st_crosses()

-   st_within(), st_is_within_distance()

-   st_contains(), st_contains_properly()

-   st_overlaps()

-   st_equals(), st_equals_exact()

-   st_covers(), st_covered_by()

#### Geometric measurements

-   st_area()

-   st_length()

-   st_perimeter()

-   st_distance()

#### Examples

This first example shows how to find the nearest aerodrome to each city, and calculate theirs distance:

```{r}
# find the nearest aerodrome indices
nearest = st_nearest_feature(places, aerodromes_3005)
nearest
```

```{r}
# join the closest aerodrome name and calculate distance
places = places |>
  mutate(
    closest_aero = st_join(places, aerodromes_3005, st_nearest_feature)[["aerodrome_name"]],
    closest_dist = st_distance(places, aerodromes_3005[nearest, ], by_element = TRUE)
  )
places |>
  as.data.frame() |>
  select(place_name_en, closest_aero, closest_dist) |>
  head(5)
```

In this next example we find populated places that are located within a 1-km buffer from watercourses:

```{r}
# select places within a 1-km buffer around rivers
flooded_places = places[lengths(st_intersects(places, st_buffer(watercourses, 1000)))>0,]

flooded_places |>
  as.data.frame() |>
  select(place_name_en) |>
  head(5)
```

```{r}
# visualization of flooded places
mapview(places, col.region = "green", cex = 3) +
  mapview(flooded_places, col.region = "black", alpha.regions = 1) +
  mapview(watercourses, color = "blue") +
  mapview(st_buffer(watercourses, 1000), col.region = "pink")
```

Dissolving internal boundaries is a common spatial operation. Here we use [`tidyverse`](https://r-spatial.github.io/sf/reference/tidyverse.html) methods and the implicit function `st_union()` to get a layer of the boundary of the city:

```{r}
vic_boundary = vic_nhoods |> summarise()
mapview(vic_boundary)
```

In the following example we count the number of business licences located in the North Park neighborhood:

```{r}
# subset neighbourhoods: North Park
north_park = vic_nhoods |>
  filter(Neighbourhood == "North Park")

# select all hedges inside North Park
north_park_licences = vic_business[lengths(st_intersects(vic_business, north_park)) > 0, ]
mapview(
  north_park_licences,
  layer.name = paste("licences:", nrow(north_park_licences)),
  col.regions = "red") + north_park
```

Now, we count the number of business licences in all the neighborhoods:

```{r}
# count number of business licences in each neighborhood
vic_nhoods$n_licences = lengths(st_intersects(vic_nhoods, vic_business))

mapview(
  filter(vic_nhoods, n_licences > 0),
  zcol = "n_licences",
  layer.name = "licences")
```

Data aggregation data can also be done by using Uber's [`H3`](https://h3geo.org) global indexing system. Note that all `sf` objects - for the `h3` package functions - must use `CRS = 4326 (WGS84)`.

![H3: Hexagonal Hierarchical Spatial Index](https://blog.uber-cdn.com/cdn-cgi/image/width=2160,quality=80,onerror=redirect,format=auto/wp-content/uploads/2018/06/Twitter-H3.png){fig-align="center"}

```{r}
#| output: false
library(h3jsr)
```

```{r}
# get h3 indices of hexagons located inside the neighborhoods
h3_idxs = polygon_to_cells(
  geometry = st_transform(vic_nhoods, 4326),
  res = 10
)

# create hexagons
h3_nhoods = cell_to_polygon(
  input = unlist(h3_idxs),
  simple = FALSE
)

mapview(
  list(vic_nhoods, h3_nhoods),
  color = list("purple", "black"),
  alpha.regions = list(0.5, 0),
  legend = list(FALSE, FALSE)
)
```

Now, let's count the number of licences inside each hexagon:

```{r}
# count number of licences per hexagon
h3_nhoods$n_licences = lengths(st_intersects(h3_nhoods, st_transform(vic_business, 4326)))

mapview(
  filter(h3_nhoods, n_licences > 0),
  zcol = "n_licences",
  layer.name = "licences")
```

### Visualization

*All the code blocks in this section must be copied and pasted into an R script.*

First, we will access geospatial data sets hosted on [Overture Maps](https://overturemaps.org) cloud. This data uses a column-oriented data format is called [GeoParquet](https://geoparquet.org), which was designed to be used in distributed systems.

```{r}
#| eval: false
library(arrow)

# connect to Overture Maps buildings
buildings = open_dataset('s3://overturemaps-us-west-2/release/2024-09-18.0/theme=buildings?region=us-west-2')
# nrow(buildings). # 2+ billion buildings
```

Let's download all the buildings in Victoria:

```{r}
#| eval: false
# extract bbox
vic_bbox = st_bbox(st_transform(vic_nhoods, 4326))

# read into memory all buildings in Victoria
vic_buildings = buildings |>
  filter(bbox$xmin > vic_bbox[1],
         bbox$ymin > vic_bbox[2],
         bbox$xmax < vic_bbox[3],
         bbox$ymax < vic_bbox[4]) |>
  select(id, geometry, height) |>
  collect() |>
  st_as_sf(crs = 4326) |>
  mutate(height = ifelse(is.na(height), 8, height))

# mapview
mapview(vic_buildings, layer.name = nrow(vic_buildings))
```

Using `rdeck`, 2D and 3D maps can be created. A [Mapbox](https://www.mapbox.com) token is required. The easiest configuration is to save the token in the user's `.Renviron` file.

```{r}
#| eval: false
# remotes::install_github("qfes/rdeck@*release")
library(rdeck)

rdeck(map_style = mapbox_dark(),
      initial_view_state = view_state(
        center = c(-123.3479, 48.45627),
        zoom = 11,
        bearing = 15,
        pitch = 85
      )) |>
  add_polygon_layer(
    data = vic_buildings,
    name = "Victoria, BC",
    get_polygon = geometry,
    get_elevation = height,
    get_fill_color = scale_color_linear(
      col = height,
      palette = viridisLite::inferno(100, direction = -1)
    ),
    extruded = TRUE,
    opacity = 0.2
    )
```

There are several mapping libraries for visualiazing spatial data. Here is an example using `mapgl`. Some functions from this package also requires a [Mapbox](https://www.mapbox.com) token.

```{r}
#| eval: false
library(mapgl)

maplibre() |>
 add_navigation_control() |>
 add_fullscreen_control() |>
 add_scale_control() |>
 fit_bounds(vic_buildings) |>
 add_fill_extrusion_layer(
   id = "Buildings",
   source = vic_buildings,
   fill_extrusion_color = "orange",
   fill_extrusion_height = list(
     "interpolate",
     list("linear"),
     list("zoom"),
     10,
     0,
     16,
     list("get", "height")
   )
 ) |>
 add_layers_control(collapsible = TRUE)
```

`mapgl` can also create heatmaps:

```{r}
#| eval: false

maplibre(bounds = h3_nhoods) |>
  add_heatmap_layer(
    id = "Heatmap",
    source = vic_business,
    heatmap_opacity = 0.5,
    heatmap_radius = 20
  ) |>
  add_circle_layer(
    id = "Business Locations",
    source = vic_business,
    circle_color = "blue",
    min_zoom = 15,
    popup = "TRADE_NAME"
  )
```

## Suggested Reading

-   Edzer Pebesma, 2018. [Simple Features for R: Standardized Support for Spatial Vector Data.](https://r-spatial.github.io/sf/index.html) The R Journal [10:1, 439-446.](https://journal.r-project.org/archive/2018/RJ-2018-009/index.html)
-   Pebesma, E.; Bivand, R. (2023). [Spatial Data Science: With Applications in R (1st ed.)](https://r-spatial.org/book). 314 pages. Chapman and Hall/CRC, Boca Raton. https://doi.org/10.1201/9780429459016
